name: Check DoctorQube Number (Multi-site Safe)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

jobs:
  check:
    runs-on: ubuntu-slim

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Read site list
        id: read_sites
        run: |
          jq -c '.[]' sites.json > sites_list.txt
          echo "[DEBUG] Sites loaded:"
          cat sites_list.txt

      - name: Process each site safely
        run: |
          set -euo pipefail

          mkdir -p results pages

          # 全角 → 半角
          z2h() { echo "$1" | perl -CSD -pe 'tr/０-９/0-9/'; }

          # ---- HTML 内の「午前/午後」見出しをマーカー化 ----
          annotate_section_from_html() {
            local HTML="$1"

            printf "%s" "$HTML" \
              | perl -0777 -pe '
                  s/【([^】]*?(午前)[^】]*)】/\n[午前：]【$1】\n/igs;
                  s/【([^】]*?(午後)[^】]*)】/\n[午後：]【$1】\n/igs;

                  s/<br\s*\/?>/\n/ig;
                  s{</p>}{\n}ig;
                  s{</div>}{\n}ig;
                  s{</li>}{\n}ig;
                  s{</tr>}{\n}ig;
                  s{</td>}{\n}ig;

                  s/<[^>]+>//g;

                  s/\r/\n/g;
                  s/\n{2,}/\n/g;
                  s/^[ \t]+//mg;
                  s/[ \t]+$//mg;
                '
          }

          # ---- 正規表現マッチ（\K 前提・マッチ部分そのものを取得）----
          extract_matches() {
            local RULE="$1"
            local INPUT="$2"
            local OUT=""

            MATCH_LINES=$(printf "%s" "$INPUT" | grep -nP "$RULE" || true)
            if [ -n "$MATCH_LINES" ]; then
              while IFS= read -r ml; do
                ln=$(echo "$ml" | cut -d: -f1)
                line=$(echo "$ml" | cut -d: -f2-)

                # 行頭の [午前：] / [午後：] を取得
                prefix=$(sed -n "${ln}p" <<< "$INPUT" | sed -E 's/^\[([^\]]*)\].*/\1/')

                # ★FIX: 置換ではなく「マッチ部分そのもの」を取得
                VAL=$(printf "%s" "$line" | perl -CS -ne "
                  if (/$RULE/) {
                    print \$&;
                  }
                ")

                # 全角→半角
                VAL=$(printf "%s" "$VAL" | perl -CS -pe 'tr/０-９/0-9/')

                if [ -n "$VAL" ]; then
                  if [ -z "$prefix" ]; then
                    OUT+="${VAL}"$'\n'
                  else
                    OUT+="${prefix}${VAL}"$'\n'
                  fi
                fi
              done <<< "$MATCH_LINES"
            fi

            printf "%s" "$OUT"
          }

          while read SITE; do
            NAME=$(echo "$SITE" | jq -r '.name')
            URL=$(echo "$SITE" | jq -r '.url')
            RULES=$(echo "$SITE" | jq -r '.rules')

            echo "[INFO] Processing $NAME ($URL)"

            curl -s "$URL" > "pages/${NAME}.html"
            HTML_RAW=$(cat "pages/${NAME}.html")

            TEXT=$(annotate_section_from_html "$HTML_RAW")
            echo "$TEXT" > "pages/${NAME}.txt"

            RULE_MATCHES=""
            while IFS="=" read -r RULE_NAME RULE_PATTERN; do
              MATCH_RESULT=$(extract_matches "$RULE_PATTERN" "$TEXT")
              if [ -n "$MATCH_RESULT" ]; then
                INDENTED=$(printf "%s" "$MATCH_RESULT" | sed 's/^/  - /')
                RULE_MATCHES+="・$RULE_NAME:\n$INDENTED"$'\n'
              fi
            done <<< "$(echo "$RULES" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')"

            echo "[DEBUG][$NAME] Matched rules:"
            echo "$RULE_MATCHES"

            NEW_STATE_FILE="results/${NAME}_state.json.new"
            jq -n --arg r "$RULE_MATCHES" '{rules:$r}' > "$NEW_STATE_FILE"

            STATE_FILE="results/${NAME}_state.json"
            CHANGE_FLAG="results/${NAME}_changed.flag"

            if [ ! -f "$STATE_FILE" ] || [ "$(jq -S . "$STATE_FILE")" != "$(jq -S . "$NEW_STATE_FILE")" ]; then
              echo "changed" > "$CHANGE_FLAG"
            fi

          done < sites_list.txt

      - name: Notify Slack for changed sites
        run: |
          while read SITE; do
            NAME=$(echo "$SITE" | jq -r '.name')
            URL=$(echo "$SITE" | jq -r '.url')
            CHANGE_FLAG="results/${NAME}_changed.flag"
            [ -f "$CHANGE_FLAG" ] || continue

            STATE_NEW="results/${NAME}_state.json.new"
            RULE_MATCHES=$(jq -r '.rules' "$STATE_NEW")

            if [ -z "$RULE_MATCHES" ]; then
              echo "[INFO] Skip Slack: no matched rules for $NAME"
              continue
            fi

            MESSAGE="*${NAME}*\n番号が更新されました\n${RULE_MATCHES}\n${URL}"

            curl -X POST -H 'Content-type: application/json' \
              --data "{ \"channel\": \"#${NAME}\", \"text\": \"${MESSAGE}\" }" \
              "${{ secrets.SLACK_WEBHOOK_URL }}"

            curl -X POST \
              -H "Content-Type: application/json" \
              --data "{ \"text\": \"${MESSAGE}\" }" \
              "${{ secrets.PHONE_HOOK_URL }}"

          done < sites_list.txt

      - name: Save new states
        run: |
          while read SITE; do
            NAME=$(echo "$SITE" | jq -r '.name')
            mv "results/${NAME}_state.json.new" "results/${NAME}_state.json"
          done < sites_list.txt

          git config user.name github-actions
          git config user.email github-actions@github.com
          git add results
          git commit -m "Update states" || true
          git push || true

      - name: Upload debug artifacts
        uses: actions/upload-artifact@v4
        with:
          name: debug-pages
          path: |
            pages/
            results/
