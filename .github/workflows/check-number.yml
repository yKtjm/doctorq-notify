name: Check DoctorQube Number (Multi-site Safe)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

jobs:
  check:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Read site list
        id: read_sites
        run: |
          jq -c '.[]' sites.json > sites_list.txt
          echo "[DEBUG] Sites loaded:"
          cat sites_list.txt

      - name: Process each site safely
        run: |
          set -euo pipefail

          mkdir -p results pages

          # 全角 → 半角
          z2h() { echo "$1" | sed 'y/９８７６５４３２１０/9876543210/'; }

          while read SITE; do
            NAME=$(echo "$SITE" | jq -r '.name')
            URL=$(echo "$SITE" | jq -r '.url')
            RULE_CURRENT=$(echo "$SITE" | jq -r '.rules.current')
            RULE_ABSENT=$(echo "$SITE" | jq -r '.rules.absent')
            RULE_NEXT=$(echo "$SITE" | jq -r '.rules.next')

            echo "[INFO] Processing $NAME ($URL)"

            # HTML取得 & テキスト化
            curl -s "$URL" > "pages/${NAME}.html"
            TEXT=$(sed 's/<[^>]*>//g' "pages/${NAME}.html")
            echo "$TEXT" > "pages/${NAME}.txt"

            # ---- 複数マッチ抽出（安全版） ----
            extract_matches() {
              local RULE="$1"
              local INPUT="$2"
              local OUT=""
              MATCHES=$(echo "$INPUT" | grep -oP "$RULE" || true)
              if [ -n "$MATCHES" ]; then
                while read -r v; do
                  VAL=$(echo "$v" | perl -pe "s/$RULE/\$1/")
                  VAL=$(z2h "$VAL")
                  OUT+="$VAL"$'\n'
                done <<< "$MATCHES"
              fi
              echo "$OUT"
            }

            CURRENT=$(extract_matches "$RULE_CURRENT" "$TEXT")
            ABSENT=$(extract_matches "$RULE_ABSENT" "$TEXT" | tr '、' ',')
            NEXT=$(extract_matches "$RULE_NEXT" "$TEXT")

            # デバッグ出力
            echo "[DEBUG][$NAME] CURRENT numbers:"
            echo "$CURRENT"
            echo "[DEBUG][$NAME] ABSENT numbers:"
            echo "$ABSENT"
            echo "[DEBUG][$NAME] NEXT numbers:"
            echo "$NEXT"

            # JSON に保存
            NEW_STATE_FILE="results/${NAME}_state.json.new"
            jq -n --arg c "$CURRENT" --arg a "$ABSENT" --arg n "$NEXT" \
              '{current:$c, absent:$a, next:$n}' > "$NEW_STATE_FILE"

            STATE_FILE="results/${NAME}_state.json"
            CHANGE_FLAG="results/${NAME}_changed.flag"

            # 差分比較
            if [ ! -f "$STATE_FILE" ] || [ "$(jq -S . "$STATE_FILE")" != "$(jq -S . "$NEW_STATE_FILE")" ]; then
              echo "changed" > "$CHANGE_FLAG"
            fi

          done < sites_list.txt

      - name: Notify Slack for changed sites
        run: |
          while read SITE; do
            NAME=$(echo "$SITE" | jq -r '.name')
            URL=$(echo "$SITE" | jq -r '.url')
            CHANGE_FLAG="results/${NAME}_changed.flag"
            [ -f "$CHANGE_FLAG" ] || continue

            STATE_NEW="results/${NAME}_state.json.new"
            CURRENT=$(jq -r '.current' "$STATE_NEW")
            ABSENT=$(jq -r '.absent' "$STATE_NEW")
            NEXT=$(jq -r '.next' "$STATE_NEW")

            # 全項目空なら通知しない
            if [ -z "$CURRENT" ] && [ -z "$ABSENT" ] && [ -z "$NEXT" ]; then
              echo "[INFO] Skip Slack: all values empty for $NAME"
              continue
            fi

            # 複数マッチを箇条書き形式
            format_list() {
              echo "$1" | sed '/^$/d' | sed 's/^/- /g'
            }

            CURRENT_FMT=$(format_list "$CURRENT")
            ABSENT_FMT=$(format_list "$ABSENT")
            NEXT_FMT=$(format_list "$NEXT")

            CHANNEL="#${NAME}"
            MESSAGE="*${NAME}*\n番号が更新されました\n・診療中:\n${CURRENT_FMT}\n・ご不在:\n${ABSENT_FMT}\n・次番号:\n${NEXT_FMT}\n${URL}"

            curl -X POST -H 'Content-type: application/json' \
              --data "{ \"channel\": \"${CHANNEL}\", \"text\": \"${MESSAGE}\" }" \
              "${{ secrets.SLACK_WEBHOOK_URL }}"

          done < sites_list.txt

      - name: Save new states
        run: |
          while read SITE; do
            NAME=$(echo "$SITE" | jq -r '.name')
            mv "results/${NAME}_state.json.new" "results/${NAME}_state.json"
          done < sites_list.txt

          git config user.name github-actions
          git config user.email github-actions@github.com
          git add results
          git commit -m "Update states" || true
          git push || true

      - name: Upload debug artifacts
        uses: actions/upload-artifact@v4
        with:
          name: debug-pages
          path: |
            pages/
            results/
