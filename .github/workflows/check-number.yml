name: Check DoctorQube Number (Multi-site Safe)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

jobs:
  check:
    runs-on: ubuntu-slim

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Read site list
        id: read_sites
        run: |
          jq -c '.[]' sites.json > sites_list.txt
          echo "[DEBUG] Sites loaded:"
          cat sites_list.txt

      - name: Process each site safely
        run: |
          set -euo pipefail

          mkdir -p results pages

          # 全角 → 半角
          z2h() { echo "$1" | perl -CSD -pe 'tr/０-９/0-9/'; }

          # ---- HTML 内の「午前/午後」見出しをマーカー化して改行を保持する ----
          # 入力: raw HTML
          # 出力: テキスト（各行の先頭に [午前：] または [午後：] が付く行がある）
          annotate_section_from_html() {
            local HTML="$1"

            # 1) 見出し（角括弧内に「午前」/「午後」が含まれるもの）を行頭マーカーに置換
            #    例: 【今日(1/1)の午後の順番】 -> \n[午後：]【今日(1/1)の午後の順番】\n
            # 2) <br>, </p>, </div>, </li>, </tr>, </td> 等を改行に置換
            # 3) タグを削除してテキスト化
            printf "%s" "$HTML" \
              | perl -0777 -pe '
                  # 1. 見出しをマーカー化（括弧内部に「午前」または「午後」がある場合）
                  s/【([^】]*?(午前)[^】]*)】/\n[午前：]【$1】\n/igs;
                  s/【([^】]*?(午後)[^】]*)】/\n[午後：]【$1】\n/igs;

                  # 2. ブロック要素を改行に（br と閉じタグの一部）
                  s/<br\s*\/?>/\n/ig;
                  s{</p>}{\n}ig;
                  s{</div>}{\n}ig;
                  s{</li>}{\n}ig;
                  s{</tr>}{\n}ig;
                  s{</td>}{\n}ig;

                  # 3. タグを全て削除（残ったテキストを得る）
                  s/<[^>]+>//g;

                  # 4. 連続改行を一つにまとめ、行頭・行末の空白をトリム
                  s/\r/\n/g;
                  s/\n{2,}/\n/g;
                  s/^[ \t]+//mg;
                  s/[ \t]+$//mg;
                '

          }

          # ---- 正規表現マッチ（prefix を行頭のマーカーから取得） ----
          # RULE はキャプチャ ( ) を使って値を取り出す前提
          extract_matches() {
            local RULE="$1"
            local INPUT="$2"
            local OUT=""

            # マッチした行を行番号つきで取得
            MATCH_LINES=$(printf "%s" "$INPUT" | grep -nP "$RULE" || true)
            if [ -n "$MATCH_LINES" ]; then
              while IFS= read -r ml; do
                # 行番号:行内容
                ln=$(echo "$ml" | cut -d: -f1)
                line=$(echo "$ml" | cut -d: -f2-)

                # その行の prefix を INPUT から取得（例: [午後：] の部分）
                prefix=$(sed -n "${ln}p" <<< "$INPUT" | sed -E 's/^\[([^\]]*)\].*/\1/')

                # 値抽出（正規表現のキャプチャを $1 として取り出す）
                VAL=$(printf "%s" "$line" | perl -CS -pe "s/${RULE}/\$1/")
                # 全角数字を半角化
                VAL=$(printf "%s" "$VAL" | perl -CS -pe 'tr/０-９/0-9/')

                # もし prefix が空文字（見出しマーカーが来ていない）なら空白を除去して prefix を空にする
                if [ -z "$prefix" ] || [ "$prefix" = "" ]; then
                  OUT+="${VAL}"$'\n'
                else
                  OUT+="${prefix}${VAL}"$'\n'
                fi
              done <<< "$MATCH_LINES"
            fi

            printf "%s" "$OUT"
          }

          while read SITE; do
            NAME=$(echo "$SITE" | jq -r '.name')
            URL=$(echo "$SITE" | jq -r '.url')
            RULES=$(echo "$SITE" | jq -r '.rules')

            echo "[INFO] Processing $NAME ($URL)"

            # HTML取得
            curl -s "$URL" > "pages/${NAME}.html"
            HTML_RAW=$(cat "pages/${NAME}.html")

            # annotate: HTML → テキスト（セクションマーカー保持）
            TEXT=$(annotate_section_from_html "$HTML_RAW")
            echo "$TEXT" > "pages/${NAME}.txt"

            # ---- 各ルールに対してマッチング ----
            RULE_MATCHES=""
            while IFS="=" read -r RULE_NAME RULE_PATTERN; do
              MATCH_RESULT=$(extract_matches "$RULE_PATTERN" "$TEXT")
              if [ -n "$MATCH_RESULT" ]; then
                INDENTED=$(printf "%s" "$MATCH_RESULT" | sed 's/^/  - /')
                RULE_MATCHES+="・$RULE_NAME:\n$INDENTED"$'\n'
              fi
            done <<< "$(echo "$RULES" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')"

            echo "[DEBUG][$NAME] Matched rules:"
            echo "$RULE_MATCHES"

            # JSONに保存（差分判定用）
            NEW_STATE_FILE="results/${NAME}_state.json.new"
            jq -n --arg r "$RULE_MATCHES" '{rules:$r}' > "$NEW_STATE_FILE"

            STATE_FILE="results/${NAME}_state.json"
            CHANGE_FLAG="results/${NAME}_changed.flag"

            # 差分比較
            if [ ! -f "$STATE_FILE" ] || [ "$(jq -S . "$STATE_FILE")" != "$(jq -S . "$NEW_STATE_FILE")" ]; then
              echo "changed" > "$CHANGE_FLAG"
            fi

          done < sites_list.txt

      - name: Notify Slack for changed sites
        run: |
          while read SITE; do
            NAME=$(echo "$SITE" | jq -r '.name')
            URL=$(echo "$SITE" | jq -r '.url')
            CHANGE_FLAG="results/${NAME}_changed.flag"
            [ -f "$CHANGE_FLAG" ] || continue

            STATE_NEW="results/${NAME}_state.json.new"
            RULE_MATCHES=$(jq -r '.rules' "$STATE_NEW")

            # 全項目空なら通知しない
            if [ -z "$RULE_MATCHES" ]; then
              echo "[INFO] Skip Slack: no matched rules for $NAME"
              continue
            fi

            # ルール名と値をコロン区切りで表示
            MESSAGE="*${NAME}*\n番号が更新されました\n${RULE_MATCHES}\n${URL}"

            curl -X POST -H 'Content-type: application/json' \
              --data "{ \"channel\": \"#${NAME}\", \"text\": \"${MESSAGE}\" }" \
              "${{ secrets.SLACK_WEBHOOK_URL }}"

            curl -X POST \
              -H "Content-Type: application/json" \
              --data "{ \"text\": \"${MESSAGE}\" }" \
              "${{ secrets.PHONE_HOOK_URL }}" 

          done < sites_list.txt

      - name: Save new states
        run: |
          while read SITE; do
            NAME=$(echo "$SITE" | jq -r '.name')
            mv "results/${NAME}_state.json.new" "results/${NAME}_state.json"
          done < sites_list.txt

          git config user.name github-actions
          git config user.email github-actions@github.com
          git add results
          git commit -m "Update states" || true
          git push || true

      - name: Upload debug artifacts
        uses: actions/upload-artifact@v4
        with:
          name: debug-pages
          path: |
            pages/
            results/
